# Handoff - Resonance
**Date:** 2025-12-12 19:30 | **Branch:** main

## Summary
Completed domain model re-architecture and designed LLM integration architecture. All domain models now follow interface + class pattern (IModel for external layers, Model class with behavior for domain). Designed but not yet implemented the "World Intelligence" system for LLM-powered queries with dynamic capabilities.

## Completed
- Domain model refactoring merged to main (PR #43)
- Created 10 domain models: User, World, Tag, Template, PropertyDefinition, Property, EntityDefinition, Entity, RelationshipDefinition, Relationship
- Renamed `entities/` â†’ `models/` to avoid confusion with Entity domain model
- Added branded IDs: UserId, WorldId, TagId, TemplateId, PropertyId, EntityDefinitionId, PropertyDefinitionId, EntityId, RelationshipDefinitionId, RelationshipId, EmbeddingChunkId
- Value objects: EntityReference, PropertyUsage, EmbeddingChunk
- Files: `packages/backend/src/domain/models/*`, `packages/backend/src/domain/value-objects/*`

## In Progress / Blocked
- LLM integration architecture designed but not implemented
- Need to create: WorldQuery, QueryResponse, QueryContext, InfoCapability, InfoRequest models
- Need to create: WorldIntelligenceService, ContextBuilderService, CapabilityResolver, InfoRequestFulfiller services
- Need to create: IWorldIntelligence, IVectorSearch, IGraphQuery ports

## Key Decisions
1. **Domain defines LLM contract**: QueryResponse = Answer | NeedsMoreInfo discriminated union. Domain handles retry logic (3 attempts with correction prompt).
2. **RAG strategy is domain logic**: RetrievalStrategy defines what/how much to retrieve. Domain says WHAT, infrastructure says HOW.
3. **Dynamic capabilities**: InfoCapability offered only when useful. CapabilityResolver uses QueryContext state. `constrainToContextIds` flag prevents hallucination by injecting valid IDs as enum.
4. **NeedsMoreInfo loop**: Max 3 info requests. Track fulfilled to prevent loops. Force answer if stuck.
5. **QueryContext is rich model**: Has behavior like `markExpanded()`, `merge()`, `hasExpandableEntities()`. Tracks `fullyExpandedEntityIds` for O(1) capability resolution.

## Next Steps
1. Create WorldQuery model (`domain/models/world-query.ts`)
2. Create QueryResponse types (Answer, NeedsMoreInfo) (`domain/models/query-response.ts`)
3. Create InfoCapability and InfoRequest types (`domain/models/info-capability.ts`)
4. Create QueryContext class with behavior (`domain/models/query-context.ts`)
5. Create capability definitions (`domain/capabilities.ts`)
6. Create service ports: IWorldIntelligence, IVectorSearch, IGraphQuery
7. Create domain services: WorldIntelligenceService, ContextBuilderService, CapabilityResolver, InfoRequestFulfiller

## Memory IDs
- e1e7909d-9761-4963-a2f8-96372de9df5e (LLM integration architecture)
- 3a63ae8e-8260-48fe-9610-32e1e8b85e86 (RAG strategy as domain logic)
- a0703dee-386b-431a-8725-b0eb6c0973eb (Dynamic capability system)
- 050ad1e4-9513-495e-96c7-373eb6ecaffd (NeedsMoreInfo loop)
- 5ba7e6e0-71f4-4572-af7c-1da1e759d7cc (QueryContext rich model)
- 8a9b1432-b64a-481d-a68c-97de0994be38 (Domain model summary from earlier)
