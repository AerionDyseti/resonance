{
  "collection": "resonance_design",
  "exported_at": "2025-10-18",
  "description": "Resonance project memories - design decisions, architecture, and session summaries",
  "documents": [
    {
      "id": "architecture",
      "content": "# Resonance Architecture and Design\n\n## Core Concept\nA Notion-inspired world building system where each world defines its own entity types, combining structured properties with markdown content, stored in Chroma for semantic search and AI integration.\n\n## Key Requirements\n\n### Content Tracking\n- Characters & NPCs\n- Locations & Maps\n- Lore & History\n- Items & Artifacts\n- Organizations & Factions\n\n### Platform\n- Web frontend (framework TBD)\n- MCP server for LLM integration\n\n### Data Storage\n- Chroma (vector database) for semantic search and embeddings\n- SQLite for metadata and schema definitions\n- Hybrid approach leveraging both systems\n\n### Content Format\n- Mixed approach: Structured forms for properties + Markdown for descriptions\n- Property references: {{property}} syntax in markdown\n- Entity transclusion: [[entity]] syntax to include other entity content\n\n### Schema System\n- Fully customizable entity types per world\n- Mixins/Traits for reusable property groups\n- Hybrid template system: base templates extensible with custom fields\n- Schema import/export via YAML/JSON for version control\n\n### Property Types\n- Basic: text, number, date, boolean, URL, email\n- Rich: select, multi-select, tags, status\n- Relations: entity references with cardinality rules (one-to-one, one-to-many, many-to-many)\n\n### Validation\n- Reference integrity (ensure all links are valid)\n- Timeline consistency checking\n- Name uniqueness within categories\n- Required fields and value constraints\n- Relationship cardinality rules\n\n### Navigation\n- Hierarchical browsing (World â†’ Continent â†’ Region â†’ City)\n- Semantic search using AI/vector embeddings\n- Tag system for flexible categorization\n\n### Advanced Features\n- Timeline management with chronological consistency\n- Campaign snapshots for version control\n- World change tracking\n- Spoiler protection system\n- Export control for data sharing\n\n### MCP Integration\n- Query tools for natural language exploration\n- Context building (gather relevant info for scenes/characters)\n- Consistency checking against world rules\n- Content generation assistance\n\n### Search & Filtering\n- Property filters with operators (equals, contains, gt, lt, etc.)\n- Advanced queries with AND/OR logic\n- Saved filters/views for reuse\n\n### Relationship Visualization\n- Multiple view modes (graph, tree, network)\n- Interactive visualizations\n- Different layouts based on relationship types",
      "metadata": {
        "project": "resonance",
        "type": "architecture"
      }
    },
    {
      "id": "data_model",
      "content": "# Resonance Data Model\n\n## Entity Structure\nEach entity combines:\n- **Properties**: Structured data fields defined by the entity type schema\n- **Markdown Body**: Free-form content with property refs and transclusion\n- **Metadata**: Created/updated timestamps, tags, permissions\n\n## Schema Definition\n\n### World Level\n- Each world has its own custom schema\n- Defines entity types specific to that world\n- Contains mixin definitions\n\n### Mixins (Traits)\nReusable property groups that can be composed:\n```python\n\"mortal\": {\n  \"birth_date\": {\"type\": \"date\"},\n  \"death_date\": {\"type\": \"date\"},\n  \"age\": {\"type\": \"number\", \"computed\": true}\n}\n```\n\n### Entity Types\nCompose mixins + custom properties:\n```python\n\"character\": {\n  \"mixins\": [\"mortal\", \"located\"],\n  \"properties\": {\n    \"name\": {\"type\": \"text\", \"required\": true},\n    \"allegiance\": {\"type\": \"relation\", \"target\": \"faction\"}\n  }\n}\n```\n\n## Storage Architecture\n\n### Chroma Collections\n- Store entity content with vector embeddings\n- Enable semantic search across all properties and markdown\n- Metadata stored alongside for filtering\n\n### SQLite Tables\n- `worlds`: World metadata and settings\n- `schemas`: Entity type definitions\n- `mixins`: Reusable property group definitions\n- `saved_filters`: User-created filter/view definitions\n- `campaign_snapshots`: Campaign snapshot metadata\n\n## Relationship Model\n- Typed relationships via relation properties\n- Bidirectional support with inverse relationships\n- Cardinality constraints\n- Stored in Chroma metadata + graph structure",
      "metadata": {
        "project": "resonance",
        "type": "data_model"
      }
    },
    {
      "id": "tech_stack",
      "content": "# Resonance Technology Stack\n\n## Backend\n- **Framework**: FastAPI (Python 3.11+)\n- **Data Models**: Pydantic V2\n- **Async Support**: uvicorn with asyncio\n\n## Databases\n- **Vector Store**: Chroma 0.4+\n  - Persistent storage\n  - Local embeddings support\n  - Semantic search capabilities\n- **Relational**: SQLite with SQLAlchemy\n  - Schema metadata\n  - User preferences\n  - System configuration\n\n## Embeddings\n- **Default**: sentence-transformers (local, no API required)\n- **Optional**: OpenAI embeddings for better quality\n\n## MCP Integration\n- **Framework**: Python MCP SDK\n- **Tools**: Query, context building, validation, generation\n\n## Markdown Processing\n- **Parser**: python-markdown\n- **Extensions**: pymdown-extensions\n- **Front Matter**: python-frontmatter\n\n## Validation\n- **Schema**: JSON Schema for property definitions\n- **Email**: email-validator\n- **Custom**: Property type validators\n\n## Development Tools\n- **Testing**: pytest with async support\n- **Linting**: ruff, black\n- **Type Checking**: mypy\n\n## Frontend (TBD)\n- Will evaluate React, Vue, Svelte, or Next.js when ready\n- Must support rich text editing and graph visualization",
      "metadata": {
        "type": "tech_stack",
        "project": "resonance"
      }
    },
    {
      "id": "session_summary_2025_10_18",
      "content": "# Resonance Project Session Summary - 2025-10-18\n\n## Project Vision\n\nCreated Resonance: A flexible, AI-powered world building and tracking system for authors and dungeon masters. The core concept is a Notion-inspired system where each world defines its own entity types, combining structured properties with markdown content.\n\n## Key Design Decisions\n\n### 1. Fully Customizable Entity System\n**Decision**: Entities are entirely defined per-world, rather than using preset templates.\n\n**Rationale**: \n- Maximum flexibility for different world-building needs\n- Each world can have completely different entity types\n- More upfront work but significantly more customizable\n- Users define their own schemas rather than being limited to predefined structures\n\n**Alternative Considered**: Hybrid template system with base templates that could be extended\n- Rejected in favor of full customization for maximum flexibility\n\n### 2. Entity Structure: Properties + Markdown Body\n**Decision**: Entities combine structured data (\"Page Properties\") with freeform markdown (\"Page Body\"), similar to Notion databases.\n\n**Features**:\n- Properties: Structured fields with types and validation\n- Markdown Body: Freeform content with special syntax\n- Property References: `{{property}}` syntax to reference property values inline\n- Entity Transclusion: `[[entity]]` syntax to include content from other entities\n\n**Rationale**: Best of both worlds - structure where needed, flexibility where desired\n\n### 3. Mixin/Trait System for Property Composition\n**Decision**: Implement mixins (reusable property groups) that can be composed to create entity types.\n\n**Example**:\n```python\n\"mortal\" mixin: {birth_date, death_date, age}\n\"located\" mixin: {location}\n\"character\" = \"mortal\" + \"located\" + {name, title, allegiance, level}\n```\n\n**Rationale**: \n- DRY principle - define common properties once\n- Flexible composition rather than rigid inheritance\n- Easy to share common behavior across entity types\n\n**Alternative Considered**: Type hierarchy with inheritance\n- Rejected as too rigid; mixins provide more flexibility\n\n### 4. Hybrid Database Architecture\n**Decision**: Use Chroma (vector database) + SQLite rather than traditional relational or graph databases.\n\n**Architecture**:\n- **Chroma**: Stores entity content with embeddings for semantic search\n- **SQLite**: Stores schema metadata, relationships, and configuration\n\n**Rationale**:\n- Chroma enables AI-powered semantic search across all content\n- Vector embeddings allow natural language querying\n- SQLite provides reliable structured storage for schemas and metadata\n- Hybrid approach leverages strengths of both systems\n\n**Alternatives Considered**:\n- Pure SQL: Good for structure but lacks semantic search\n- Pure Graph Database (Neo4j): Great for relationships but overkill and complex\n- Pure Document Store (MongoDB): Flexible but no semantic search built-in\n\n### 5. Property Type System\n**Decision**: Comprehensive property type system with validation.\n\n**Types Supported**:\n- **Basic**: text, number, date, boolean, URL, email\n- **Rich**: select, multi-select, tags, status\n- **Relations**: Entity references with cardinality rules\n- **Computed**: Formula-based calculated fields (future)\n\n**Validation Features**:\n- Required fields\n- Value constraints (min/max, regex patterns)\n- Relationship cardinality enforcement\n- Flexible schema (allows extra properties not in schema)\n\n**Rationale**: Balance between structure and flexibility\n\n### 6. Schema Import/Export via YAML/JSON\n**Decision**: Enable schema definitions to be exported and version controlled.\n\n**Rationale**:\n- Version control schemas alongside code\n- Share world templates with others\n- Backup and restore world structures\n- Team collaboration on world design\n\n### 7. Campaign Snapshots Instead of Full Version Control\n**Decision**: Campaign snapshots at key points rather than tracking every change.\n\n**Rationale**: \n- Balance between features and complexity\n- Snapshots capture world state at important moments\n- Avoids performance overhead of tracking every edit\n- Sufficient for most use cases (session starts, major events)\n\n**Alternative Considered**: Full version control with change history\n- Deferred to later phase; snapshots are MVP\n\n### 8. MCP Server for LLM Integration\n**Decision**: Build MCP (Model Context Protocol) server as core feature, not afterthought.\n\n**Capabilities Planned**:\n- Natural language querying of world data\n- Context building (gather relevant info for scenes/characters)\n- Consistency checking against world rules\n- Content generation assistance\n\n**Rationale**: AI integration is a differentiating feature that sets Resonance apart from traditional world-building tools\n\n### 9. Web Frontend Technology - Deferred\n**Decision**: Postpone frontend framework decision until backend is mature.\n\n**Candidates**: React/Next.js, Vue/Nuxt, SvelteKit\n\n**Rationale**: \n- Backend architecture informs frontend needs\n- Avoid premature optimization\n- Framework landscape changes quickly\n- Focus on data layer first\n\n### 10. Development Methodology: Phased + Test-Driven\n**Decision**: Break development into phases, complete with tests before moving forward.\n\n**Approach**:\n- Each phase builds on previous phases\n- Write tests first or alongside implementation\n- No moving to next phase until current is tested\n- Minimum 80% code coverage target\n\n**Rationale**: \n- Ensures solid foundation\n- Prevents technical debt accumulation\n- Makes refactoring safer\n- Documents expected behavior\n\n## Technology Stack Decisions\n\n### Backend: Python + FastAPI\n**Rationale**:\n- Python: Great ecosystem for AI/ML, data processing\n- FastAPI: Modern, fast, automatic API docs, async support\n- Pydantic: Strong typing, validation built-in\n\n### Embeddings: Local by Default (sentence-transformers)\n**Decision**: Use local embeddings model as default, OpenAI as optional.\n\n**Rationale**:\n- No API costs for basic usage\n- Privacy (data doesn't leave user's machine)\n- Works offline\n- Optional upgrade path for better quality\n\n### Testing: pytest with async support\n**Rationale**: Industry standard, excellent async support, rich plugin ecosystem\n\n## Project Management Decisions\n\n### GitHub as Project Management Tool\n**Decision**: Use GitHub Issues, Milestones, and Labels instead of Jira.\n\n**Setup**:\n- **Issues**: Individual tasks/features/bugs\n- **Milestones**: Development phases\n- **Labels**: Categorization (testing, schema, priority, etc.)\n- **Templates**: Standardized issue creation (feature, bug, test)\n\n**Rationale**: \n- Integrated with code repository\n- No additional tool cost\n- Simple, effective for solo/small team\n- Git-based workflow\n\n### Initial Commit Strategy\n**Decision**: Start with documentation only, code comes later via tickets.\n\n**First Commit Includes**:\n- README.md (project overview)\n- ROADMAP.md (phased development plan)\n- CONTRIBUTING.md (GitHub workflow)\n- Issue templates\n- .gitignore\n\n**Code Excluded from Initial Commit**:\n- Backend implementation\n- Tests\n- Requirements.txt\n\n**Rationale**:\n- User wanted to review all code carefully\n- Documentation-first approach\n- Code will be developed ticket-by-ticket with review\n\n### Claude Code Settings: Auto-approve gh Commands\n**Decision**: Auto-approve all `gh` commands except `git push`.\n\n**Configuration**:\n```json\n\"permissions\": {\n  \"allow\": [\"Bash(gh:*)\"],\n  \"ask\": [\"Bash(git push:*)\"]\n}\n```\n\n**Rationale**:\n- Streamlines GitHub CLI workflow\n- Still maintains control over repository pushes\n- Balance between automation and safety\n\n## Implementation Approach\n\n### Phase Breakdown\n1. **Phase 1**: Foundation (completed) - Project structure, docs\n2. **Phase 2**: Schema System (current) - Mixins, validation, import/export\n3. **Phase 3**: Entity Management - CRUD operations\n4. **Phase 4**: Markdown & Content - Processing with refs/transclusion\n5. **Phase 5**: Relationships - Graph management\n6. **Phase 6**: Search & Query - Semantic + filters\n7. **Phase 7**: Campaign System - Snapshots, tracking\n8. **Phase 8**: Timeline - Chronology, consistency\n9. **Phase 9**: API Layer - FastAPI routes\n10. **Phase 10**: MCP Server - LLM integration\n11. **Phase 11**: Import/Export - External formats\n12. **Phase 12**: Frontend - Web UI\n\n### Current Status\n- âœ… Phase 1 complete\n- âœ… GitHub repository created (https://github.com/AerionDyseti/resonance)\n- âœ… Documentation committed\n- âœ… Milestones created (Phases 2, 3, 4, 10)\n- âœ… Labels created (testing, schema, priority levels, feature)\n- âœ… Phase 2 issues created (7 tickets)\n- ðŸŽ¯ Next: Begin Issue #1 - Schema Builder Mixin Tests\n\n## Rejected Approaches\n\n### 1. Preset Entity Templates\n**Why Rejected**: Too limiting; users want full customization\n\n### 2. Traditional Relational Database Only\n**Why Rejected**: No semantic search capabilities; AI integration harder\n\n### 3. Graph Database (Neo4j)\n**Why Rejected**: Overkill for MVP; complexity not justified; harder deployment\n\n### 4. Frontend-First Development\n**Why Rejected**: Backend defines capabilities; premature to choose framework\n\n### 5. Full Version Control on Every Change\n**Why Rejected**: Complexity vs. value; snapshots sufficient for MVP\n\n### 6. Type Inheritance Hierarchy\n**Why Rejected**: Too rigid; mixins provide better flexibility\n\n### 7. Implementing All Features Before Testing\n**Why Rejected**: Risk of technical debt; test-driven is more robust\n\n## Key Insights\n\n### On Architecture\n- Hybrid database approach (Chroma + SQLite) provides best of both worlds\n- Per-world schema customization is more powerful than preset templates\n- Mixin composition is more flexible than inheritance\n\n### On Development Process\n- Documentation-first creates clarity\n- Test-driven development prevents rushing ahead\n- GitHub Issues work well for project management\n- Breaking into phases prevents scope creep\n\n### On User Experience\n- Notion-like interface (properties + markdown) is familiar and powerful\n- Property references and transclusion enable rich content creation\n- Semantic search makes large worlds navigable\n- MCP integration brings AI superpowers\n\n## Lessons Learned\n\n1. **Start Simple**: Documentation and planning before code\n2. **User-Driven**: User wanted to review code; reset to docs-only commit\n3. **Flexibility Matters**: Full customization > preset templates\n4. **Test Coverage**: 80% minimum ensures quality\n5. **AI-Native**: MCP integration from start, not bolted on later\n\n## Next Steps\n\n1. Create feature branch for Issue #1\n2. Implement SchemaBuilder with mixin support\n3. Write comprehensive tests\n4. Code review and merge\n5. Continue through Phase 2 tickets\n6. Build toward fully functional schema system",
      "metadata": {
        "type": "session_summary",
        "date": "2025-10-18",
        "project": "resonance"
      }
    },
    {
      "id": "decisions_log_2025_10_18",
      "content": "# Key Decisions Log - Resonance\n\n## Session: 2025-10-18 - Initial Planning\n\n### DECISION: Fully Customizable Entities Per World\n- **Date**: 2025-10-18\n- **Context**: User initially asked about hybrid templates, then decided on full customization\n- **Decision**: Each world defines its own entity types completely from scratch\n- **Alternative**: Hybrid system with base templates that could be extended\n- **Rationale**: Maximum flexibility, worth the upfront work\n- **Impact**: Core architecture decision affecting entire system\n\n### DECISION: Notion-Style Properties + Markdown\n- **Date**: 2025-10-18  \n- **Context**: How should entity content be structured?\n- **Decision**: Combine structured properties with freeform markdown body\n- **Alternatives**: Pure structured data, pure markdown, separate documents\n- **Rationale**: Best of both worlds - structure and flexibility\n- **Impact**: Defines user content creation experience\n\n### DECISION: Chroma Vector Database + SQLite\n- **Date**: 2025-10-18\n- **Context**: Primary data storage approach\n- **Decision**: Hybrid - Chroma for content/embeddings, SQLite for metadata/schemas\n- **Alternatives**: Pure SQL, pure graph DB, pure document store\n- **Rationale**: Semantic search is core feature; hybrid leverages strengths\n- **Impact**: Enables AI features, affects performance and scalability\n\n### DECISION: Mixin/Trait System for Property Composition  \n- **Date**: 2025-10-18\n- **Context**: How to reuse common properties across entity types?\n- **Decision**: Mixin system - compose entity types from reusable property groups\n- **Alternative**: Type hierarchy with inheritance\n- **Rationale**: More flexible than inheritance, easier to compose\n- **Impact**: Schema system architecture, user mental model\n\n### DECISION: MCP Server as Core Feature\n- **Date**: 2025-10-18\n- **Context**: User wanted LLM interaction from the start\n- **Decision**: Build MCP server in Phase 10, design for it from Phase 1\n- **Alternative**: Add AI features later as optional\n- **Rationale**: Differentiating feature, influences architecture\n- **Impact**: Data model designed for semantic search from start\n\n### DECISION: Campaign Snapshots vs Full Version Control\n- **Date**: 2025-10-18\n- **Context**: How to handle world state over time?\n- **Decision**: Snapshots at key moments (session starts, major events)\n- **Alternative**: Full Git-like version control on every change\n- **Rationale**: Sufficient for use cases, avoids complexity/performance overhead\n- **Impact**: Simpler implementation, good enough for MVP\n\n### DECISION: Test-Driven Phased Development\n- **Date**: 2025-10-18\n- **Context**: How to structure development workflow?\n- **Decision**: 12 phases, complete current phase tests before moving forward\n- **Alternative**: Build features then test, or build entire system then test\n- **Rationale**: Ensures solid foundation, prevents technical debt\n- **Impact**: Longer initial development but higher quality\n\n### DECISION: Defer Frontend Framework Selection\n- **Date**: 2025-10-18\n- **Context**: Which frontend framework to use?\n- **Decision**: Postpone decision until backend is mature\n- **Alternatives**: React/Next.js, Vue/Nuxt, SvelteKit\n- **Rationale**: Backend capabilities inform frontend needs, avoid premature commitment\n- **Impact**: Can make informed choice later\n\n### DECISION: Documentation-Only Initial Commit\n- **Date**: 2025-10-18\n- **Context**: User wanted to review code carefully\n- **Decision**: First commit includes only docs, code added via tickets\n- **Alternative**: Include all scaffolded code in initial commit\n- **Rationale**: User preference for careful review, ticket-by-ticket approach\n- **Impact**: Clean start, all code reviewed\n\n### DECISION: GitHub Issues for Project Management\n- **Date**: 2025-10-18\n- **Context**: User asked about using GitHub like Jira\n- **Decision**: Use Issues + Milestones + Labels + Templates\n- **Alternative**: External tool like Jira, Linear, or Asana\n- **Rationale**: Integrated with repo, free, simple, sufficient for needs\n- **Impact**: All project management in one place\n\n### DECISION: Auto-approve gh Commands\n- **Date**: 2025-10-18\n- **Context**: User wanted to streamline GitHub CLI workflow\n- **Decision**: Auto-approve all `gh` commands, always ask for `git push`\n- **Alternative**: Ask for every command\n- **Rationale**: Balance automation and control\n- **Impact**: Faster workflow, maintains safety on pushes\n\n### DECISION: Local Embeddings by Default\n- **Date**: 2025-10-18\n- **Context**: Which embedding model to use?\n- **Decision**: sentence-transformers (local) default, OpenAI optional\n- **Alternative**: Require OpenAI API from start\n- **Rationale**: Privacy, no costs, offline capability, optional upgrade\n- **Impact**: Lower barrier to entry, privacy-friendly",
      "metadata": {
        "date": "2025-10-18",
        "type": "decisions_log",
        "project": "resonance"
      }
    },
    {
      "id": "ticket_structure_decision",
      "content": "# Ticket Structure Decision - 2025-10-18\n\n## Context\n\nInitially created test tickets (#1-#7) before creating feature tickets for the implementation work. User correctly identified that tests should follow features, not precede them.\n\n## Decision: Separate Feature and Test Tickets\n\n**Date**: 2025-10-18\n\n**Problem**: Test tickets were created first, but they test code that doesn't exist yet. Need proper tracking for both implementation and testing work.\n\n**Solution**: Create separate feature tickets for implementation, update test tickets to depend on them.\n\n## Ticket Structure\n\n### Feature Tickets (Implementation)\nThese tickets represent the actual code to be written:\n\n**Infrastructure** (Must be done first):\n- **#8**: Core Database Setup (Chroma + SQLite)\n  - backend/core/config.py\n  - backend/core/database.py\n  - requirements.txt\n  - .env.example\n\n- **#9**: Shared Type Definitions\n  - shared/types.py\n  - All Pydantic models and enums\n\n- **#14**: Pytest Configuration and Test Infrastructure\n  - pytest.ini\n  - tests/conftest.py\n  - Test fixtures and configuration\n\n**Schema Builder Implementation**:\n- **#10**: Schema Builder - Mixin Operations\n  - backend/schema/builder.py (mixin methods)\n  - Create, retrieve, list mixins\n  - Tested by: #1\n\n- **#11**: Schema Builder - Entity Type Schema Operations\n  - backend/schema/builder.py (entity schema methods)\n  - Create, retrieve, update, delete schemas\n  - Tested by: #2\n\n**Schema Validator Implementation**:\n- **#12**: Schema Validator - Property Type Validation\n  - backend/schema/validator.py\n  - Validate all property types\n  - Tested by: #3\n\n- **#13**: Schema Validator - Constraints and Required Fields\n  - backend/schema/validator.py (extend)\n  - Required fields, min/max, regex, options\n  - Tested by: #4\n\n### Test Tickets (Verification)\nThese tickets represent writing tests for implemented features:\n\n- **#1**: [TEST] Schema Builder - Mixin Operations\n  - Tests: #10\n  - Depends on: #14, #10\n\n- **#2**: [TEST] Schema Builder - Entity Type Schemas\n  - Tests: #11\n  - Depends on: #14, #11\n\n- **#3**: [TEST] Schema Validator - Property Type Validation\n  - Tests: #12\n  - Depends on: #14, #12\n\n- **#4**: [TEST] Schema Validator - Constraints and Required Fields\n  - Tests: #13\n  - Depends on: #14, #13\n\n- **#5**: [TEST] Schema System Integration Tests\n  - Tests: Full workflow\n  - Depends on: #14, #10, #11, #12, #13\n  - Should follow: #1, #2, #3, #4 (unit tests first)\n\n### Schema Import/Export (Later)\n- **#6**: [FEATURE] Schema Import/Export\n- **#7**: [TEST] Schema Import/Export Tests\n\n## Recommended Implementation Order\n\n1. **#8** - Database Setup (foundation for everything)\n2. **#9** - Shared Types (used by all components)\n3. **#14** - Pytest Infrastructure (enables testing)\n4. **#10** + **#1** - Mixin implementation + tests\n5. **#11** + **#2** - Entity schemas + tests\n6. **#12** + **#3** - Validator types + tests\n7. **#13** + **#4** - Validator constraints + tests\n8. **#5** - Integration tests (after all unit tests pass)\n9. **#6** + **#7** - Import/export feature + tests\n\n## Workflow Pattern Established\n\nFor each component:\n1. Create **[FEATURE]** ticket for implementation\n2. Implement the feature\n3. Create branch: `feature/issue-N-description`\n4. Write code\n5. Write tests (or use existing **[TEST]** ticket)\n6. Ensure tests pass\n7. Create PR referencing feature ticket\n8. Review and merge\n9. Close both feature and test tickets\n\n## Rationale\n\n**Why separate tickets?**\n- Clear separation of implementation vs. testing work\n- Better tracking of progress\n- Can be worked on by different people if needed\n- Proper dependency management\n- More accurate time estimates\n\n**Why test tickets depend on feature tickets?**\n- Can't test code that doesn't exist\n- Tests verify implementation\n- Dependencies make order clear\n\n**Why infrastructure first?**\n- Database setup is required for all other work\n- Shared types are used everywhere\n- Test infrastructure enables TDD workflow\n\n## Benefits of This Approach\n\n1. **Clear Dependencies**: GitHub shows what blocks what\n2. **Parallel Work Possible**: Independent features can be worked simultaneously\n3. **Complete History**: PRs reference specific tickets\n4. **Progress Tracking**: Can see implementation vs. testing status separately\n5. **Review-Friendly**: Each PR is focused on one thing\n\n## Total Phase 2 Tickets: 14\n\n- 7 Feature tickets (#6, #8, #9, #10, #11, #12, #13, #14)\n- 5 Test tickets (#1, #2, #3, #4, #5, #7)\n- Infrastructure: 3 tickets (#8, #9, #14)\n- Schema Builder: 2 implementation + 2 test\n- Schema Validator: 2 implementation + 2 test\n- Integration: 1 test\n- Import/Export: 1 implementation + 1 test",
      "metadata": {
        "type": "decision",
        "date": "2025-10-18",
        "topic": "ticket_structure",
        "project": "resonance"
      }
    },
    {
      "id": "phase2_tickets_reference",
      "content": "# Phase 2 GitHub Issues - Complete Reference\n\n## Infrastructure Tickets\n\n### #8 - [FEATURE] Core Database Setup - Chroma and SQLite\n**Labels**: feature, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n\n**Purpose**: Set up hybrid database system (Chroma + SQLite)\n\n**Deliverables**:\n- backend/core/config.py (Settings with Pydantic)\n- backend/core/database.py (Models and DatabaseManager)\n- requirements.txt (all dependencies)\n- .env.example (configuration template)\n\n**Key Components**:\n- Chroma client initialization (persistent storage)\n- SQLite models: World, SchemaDefinition, MixinDefinition, SavedFilter, CampaignSnapshot\n- DatabaseManager singleton\n- Dependency injection helpers (get_db, get_chroma)\n\n**Dependencies**: None (foundational)\n\n### #9 - [FEATURE] Shared Type Definitions\n**Labels**: feature, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n\n**Purpose**: Create Pydantic models used across application\n\n**Deliverables**:\n- shared/types.py (all type definitions)\n- shared/__init__.py (exports)\n\n**Key Components**:\n- PropertyType enum (TEXT, NUMBER, DATE, etc.)\n- RelationCardinality enum\n- PropertyDefinition model\n- MixinDefinitionModel\n- EntityTypeSchema model\n- Entity, Relationship, WorldMetadata models\n- FilterOperator, PropertyFilter, EntityQuery\n\n**Dependencies**: None (foundational)\n\n### #14 - [FEATURE] Pytest Configuration and Test Infrastructure\n**Labels**: feature, testing, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n\n**Purpose**: Set up testing framework and shared fixtures\n\n**Deliverables**:\n- pytest.ini (configuration)\n- tests/conftest.py (shared fixtures)\n- tests/unit/ directory\n- tests/integration/ directory\n\n**Key Fixtures**:\n- temp_dir, test_settings\n- db_engine, db_session\n- chroma_client\n- sample_world_id\n- sample_mixin_properties\n- sample_entity_properties\n\n**Dependencies**: Requires #8, #9\n\n## Schema Builder Implementation\n\n### #10 - [FEATURE] Schema Builder - Mixin Operations\n**Labels**: feature, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tested by**: #1\n\n**Purpose**: Implement mixin creation and management\n\n**Deliverables**:\n- backend/schema/builder.py (SchemaBuilder class, mixin methods)\n- backend/schema/__init__.py\n\n**Methods**:\n- create_mixin(world_id, name, properties, description)\n- get_mixin(mixin_id)\n- list_mixins(world_id)\n- get_mixins_dict(world_id)\n- _mixin_db_to_model(mixin_db)\n\n**Dependencies**: Requires #8, #9\n\n### #11 - [FEATURE] Schema Builder - Entity Type Schema Operations\n**Labels**: feature, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tested by**: #2\n\n**Purpose**: Extend SchemaBuilder with entity type schemas\n\n**Deliverables**:\n- Extend backend/schema/builder.py (entity schema methods)\n\n**Methods**:\n- create_entity_type_schema(world_id, entity_type, properties, mixins, ...)\n- get_entity_type_schema(world_id, entity_type)\n- list_entity_type_schemas(world_id)\n- update_entity_type_schema(world_id, entity_type, **updates)\n- delete_entity_type_schema(world_id, entity_type)\n- _schema_db_to_model(schema_db)\n\n**Dependencies**: Requires #10\n\n## Schema Validator Implementation\n\n### #12 - [FEATURE] Schema Validator - Property Type Validation\n**Labels**: feature, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tested by**: #3\n\n**Purpose**: Validate entity properties against schemas\n\n**Deliverables**:\n- backend/schema/validator.py (SchemaValidator class)\n- Update backend/schema/__init__.py\n\n**Methods**:\n- validate_properties(properties)\n- _validate_property_value(prop_name, value, prop_def)\n- _validate_text, _validate_number, _validate_date\n- _validate_boolean, _validate_url, _validate_email\n- _validate_select, _validate_multi_select\n- _validate_tags, _validate_relation\n\n**Exception**: ValidationError\n\n**Dependencies**: Requires #9\n\n### #13 - [FEATURE] Schema Validator - Constraints and Required Fields\n**Labels**: feature, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tested by**: #4\n\n**Purpose**: Add constraint checking and required field enforcement\n\n**Deliverables**:\n- Extend backend/schema/validator.py\n\n**Enhancements**:\n- Required field checking in validate_properties\n- Min/max constraints in _validate_number\n- Regex pattern matching in _validate_text\n- Options validation in select methods\n- Improved error messages\n\n**Dependencies**: Requires #12\n\n## Test Tickets\n\n### #1 - [TEST] Schema Builder - Mixin Operations\n**Labels**: testing, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tests**: #10\n\n**Coverage Goals**:\n- Mixin creation with valid properties\n- Mixin retrieval by ID\n- List all mixins for world\n- Get mixins as dictionary\n- Handle non-existent mixin\n\n**Target**: >80% coverage\n**Dependencies**: Requires #14, #10\n\n### #2 - [TEST] Schema Builder - Entity Type Schemas\n**Labels**: testing, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tests**: #11\n\n**Coverage Goals**:\n- Entity type schema creation\n- Schema retrieval by entity type\n- List all schemas for world\n- Update existing schema\n- Delete schema\n- Schema with mixin composition\n\n**Target**: >80% coverage\n**Dependencies**: Requires #14, #11\n\n### #3 - [TEST] Schema Validator - Property Type Validation\n**Labels**: testing, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tests**: #12\n\n**Coverage Goals**:\n- All property types with valid values\n- All property types with invalid values\n- URL and EMAIL format validation\n- SELECT, MULTI_SELECT, TAGS, RELATION\n- Clear error messages\n\n**Target**: >90% coverage\n**Dependencies**: Requires #14, #12\n\n### #4 - [TEST] Schema Validator - Constraints and Required Fields\n**Labels**: testing, schema, priority:high\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tests**: #13\n\n**Coverage Goals**:\n- Required field validation\n- Min/max value constraints\n- Regex pattern validation\n- Select options validation\n- Null value handling\n- Extra properties (flexible schema)\n\n**Target**: >90% coverage\n**Dependencies**: Requires #14, #13\n\n### #5 - [TEST] Schema System Integration Tests\n**Labels**: testing, schema, priority:medium\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tests**: Full system workflow\n\n**Coverage Goals**:\n- Create mixin â†’ use in schema â†’ validate entities\n- Schema composition with multiple mixins\n- Get all properties (schema + mixins)\n- Update schema and re-validate\n- Cross-world schema isolation\n\n**Dependencies**: Requires #14, #10, #11, #12, #13; Should follow #1-#4\n\n## Later Phase 2 Work\n\n### #6 - [FEATURE] Schema Import/Export\n**Labels**: feature, schema, priority:medium\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n\n**Purpose**: YAML/JSON import/export for schemas\n\n### #7 - [TEST] Schema Import/Export Tests\n**Labels**: testing, schema, priority:medium\n**Milestone**: Phase 2: Schema System\n**Status**: Open\n**Tests**: #6\n\n**Dependencies**: Requires #6",
      "metadata": {
        "type": "reference",
        "date": "2025-10-18",
        "project": "resonance",
        "phase": "2"
      }
    }
  ],
  "import_instructions": "To import these memories on another machine:\n\n1. Ensure the MCP memory server is running with Chroma\n2. Use the memory server's add_documents tool to import each document\n3. Or use the import script (if created) in scripts/import_memories.py\n\nExample:\npython scripts/import_memories.py .claude/memory-export.json"
}
